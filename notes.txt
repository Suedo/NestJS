@Module decorator properties
--------------------------------------------------------------------------------------------------------------------------------------------
1. providers: 
array of properties to be available within the module via dependency injection

2. controllers: 
array of controllers

3. exports: 
array of providers to export to other modules

4. imports: 
List of modules required by this module. All exported providers of imported modules will be available to this module.


> All Services are providers, But All providers ARE NOT Services
> Services are singletons wrapped in an @Injectable, an 'provided' to a module (providers array). They are single source of truth, and contain business logic

Pipes
--------------------------------------------------------------------------------------------------------------------------------------------
1. Pipes are services with @Injectable decorator
2. They implement the generic `PipeTransform` interface, and thus, all pipes must have a `transform` method, which takes in two params:
  a. value: value of the processed argument
  b. metadata (optional) : object containing 
3. Whatever is returned from the `transform` method is sent to the route handler. exceptions are sent to the client

NestJS ships with two built-in pipes: 
ValidationPipe and ParseIntPipe

--> Various types of Pipes <--

1. Handler-level : defined at the handler/controller level, via the @UsePipes(<pipename>) decorator. Such pipes will process all params for the request
2. Param-level : defined per controller param, and validates that particular param only
3. Global-Pipes : defined at the application level, and used for all incoming requests






CLI
--------------------------------------------------------------------------------------------------------------------------------------------
1.
  nest g controller tasks --no-spec
  ^ generates a `tasks.controller.ts` file in the tasks module. 
  We provided a path, which had a module. thus, the cli added the controller as part of the module (tasks)


Launch.Json For Vscode Debug
--------------------------------------------------------------------------------------------------------------------------------------------
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Nest Framework",
      "args": ["${workspaceFolder}/src/main.ts"],
      "runtimeArgs": ["--nolazy", "-r", "ts-node/register"],
      "sourceMaps": true,
      "cwd": "${workspaceRoot}",
      "protocol": "inspector"
    }
  ]
}


Adding TypeOrm
--------------------------------------------------------------------------------------------------------------------------------------------
1. yarn add @nestjs/typeorm typeorm pg
2. Add a typeorm.config.ts file in a 'config' folder, where we specify db name, port, host etc
3. Add `TypeOrmModule.forRoot(typeOrmConfig)` in the imports section of app module
4. Create an Entity for your model. We create a 'task.entity.ts' in the tasks module's folder root location.
5. Create a Repository for your Task Entity. Repository is the persistence layer.
5. Add newly created Repository to forfeature part of TypeOrmModule, to make it avaible via DI thoughout the module
6. Inject Repository in constructor of service



Duplicate User Signup
--------------------------------------------------------------------------------------------------------------------------------------------
A generic case : Trying to add a resource to DB that already exists. In our case, signing up, user gives a name that is already taken.
we would want the user to be told the same. Since we are storing username and password in DB, we can create a unique constraint on username:

1. in Entity, add: @Unique(['username']) >> this sets up a unique constraint in DB
2. when attempting to save it, DB will error out, we will catch it, and throw exception etc


JWT Signin
--------------------------------------------------------------------------------------------------------------------------------------------
1. create a jwt token on validated sigin, and return token to user
2. use token in header, to access protected route

We need these four packages for passport's auth to work, grouped in a way that helps me remember:
passport + @nestjs/passport       // (wrapper over passport)
passport-jwt + @nestjs/jwt        // (wrapper over passport-jwt strategy, i think)

The `validate` mathod of JwtStrategy gets called before accessing all @UseGuard(JwtGuard) routes


Three Places where we mainly need to make changes for jwt:
1. Auth Module: src/auth/auth.module.ts:
  a) add this to the imports:

    JwtModule.register({
      secret: 'mysecret',
      signOptions: {
        expiresIn: '600s',
      },
    }),
    PassportModule.register({
      defaultStrategy: 'jwt',
    }),
  
2. Jwt Strategy: src/auth/jwt.strategy.ts:

  Passport needs a strategy provided to it. It has various strategies that it accepts. pasport-jwt is the jwt strategy.
  > @nestjs/passport is nest's wrapper over the passport module. It has a PassportStrategy funtionality that takes in a strategy
  > All passport strategies exports a strategy class. Thus, passport-jwt exports a jwt based `strategy` class, which is fed to Nest's PassportStrategy
  > All passport strategies also export a ExtractJwt class, which dictates where in the request to get the auth token from.

  Our JwtStrategy class needs to call the parent class (PassportStrategy) with :
  {
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // extraction protocol
      secretOrKey: 'mysecret', // secret
  }

  It also must have a `validate(jwtpayload)` method, which will determine if the token is valid or not

3. AuthService: src/auth/auth.service.ts:

  This will have sign-in , login etc type routes, which basically turn the unauth flow to authenticated flow.
  It's methods will take the request payload, and create an accesstoken from it, by signing it with our secret.

  This sign is where `@nestjs/jwt` JwtService comes it. it encapsulates the `sign`-ing funtionality, where we only pass it the payload to sign,
  and it takes care of everything else, based on the configurations we have done earlier... secret etc. 

  Below is the allow Login functionality:

    ```
    async allowLogin(dto: AuthCredentialsDto): Promise<{ accessToken: string }> {
      const username = await this.repository.validatePassword(dto);

      if (!username) {
        throw new UnauthorizedException('Incorrect credentials');
      }

      const payload: JwtPayload = { username };
      const accessToken = await this.jwtService.sign(payload); // already has the secret and stuff

      return { accessToken };
    }
    ```

